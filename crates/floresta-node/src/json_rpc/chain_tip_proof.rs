//! Chain-tip inclusion proofs for the Utreexo accumulator.
//!
//! This module provides [`ChainTipInclusionProof`], which represents a proof
//! that a given UTXO is included in the current chain tip's Utreexo accumulator.
//! This proof is generated by utreexod's `proveutxochaintipinclusion` RPC and
//! verified by Floresta's `verifyutxochaintipinclusionproof` RPC.

use bitcoin::consensus::Decodable;
use bitcoin::hashes::sha256;
use bitcoin::BlockHash;
use bitcoin::VarInt;
use floresta_common::read_bounded_len;
use floresta_wire::block_proof::MAX_INPUTS_PER_BLOCK;
use floresta_wire::block_proof::MAX_PROOF_HASHES;
use rustreexo::accumulator::node_hash::BitcoinNodeHash;
use rustreexo::accumulator::proof::Proof;

/// A chain-tip inclusion proof as serialized by utreexod.
///
/// Responses to `proveutxochaintipinclusion` utreexod RPC.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ChainTipInclusionProof {
    /// The block hash at which this proof was generated.
    pub proved_at_hash: BlockHash,
    /// The Utreexo accumulator proof (targets + sibling hashes).
    pub proof: Proof,
    /// The raw leaf hashes that were proven.
    pub hashes_proven: Vec<BitcoinNodeHash>,
}

impl Decodable for ChainTipInclusionProof {
    fn consensus_decode<R: bitcoin::io::Read + ?Sized>(
        reader: &mut R,
    ) -> Result<Self, bitcoin::consensus::encode::Error> {
        // Block hash (32 bytes)
        let proved_at_hash = BlockHash::consensus_decode(reader)?;

        // Targets (varint count + varint-encoded)
        let num_targets = read_bounded_len(reader, MAX_INPUTS_PER_BLOCK)?;
        let mut targets = Vec::with_capacity(num_targets);
        for _ in 0..num_targets {
            let target = VarInt::consensus_decode(reader)?;
            targets.push(target.0);
        }

        // Proof sibling hashes (varint count + 32-byte hashes)
        let num_hashes = read_bounded_len(reader, MAX_PROOF_HASHES)?;
        let mut proof_hashes = Vec::with_capacity(num_hashes);
        for _ in 0..num_hashes {
            let hash = sha256::Hash::consensus_decode(reader)?;
            proof_hashes.push(hash.into());
        }

        // Hashes proven (u32 LE count + 32-byte hashes)
        let num_proven = u32::consensus_decode(reader)? as usize;
        if num_proven > MAX_INPUTS_PER_BLOCK {
            return Err(bitcoin::consensus::encode::Error::ParseFailed(
                "Too many proven hashes",
            ));
        }
        let mut hashes_proven = Vec::with_capacity(num_proven);
        for _ in 0..num_proven {
            let hash = sha256::Hash::consensus_decode(reader)?;
            hashes_proven.push(hash.into());
        }

        Ok(ChainTipInclusionProof {
            proved_at_hash,
            proof: Proof {
                targets,
                hashes: proof_hashes,
            },
            hashes_proven,
        })
    }
}

#[cfg(test)]
mod tests {
    use bitcoin::consensus::encode::deserialize_hex;

    use super::*;

    const CHAIN_TIP_PROOF_HEX: &str = "06db48a6f377f85e46c4e0b915af21c05122c72fff2a8193e19bc68a8b18116d0100030b6c7f2192b1460acf65143badad31b1f000e4940d966bdc8d41463c3049255164028cae25759e119457b059aaa6a38e5812cfd72e9fd07a6393771b4881a2fa80500750ac49f80b161c7431cc3f345a3872147b7adb432f032956eafa9fb76801000000e1e92857db1c66b3cf610e445eb006d68373d82b33398bdadd2f70cf4088dac2";

    const CHAIN_TIP_BLOCK_HASH_HEX: &str =
        "06db48a6f377f85e46c4e0b915af21c05122c72fff2a8193e19bc68a8b18116d";

    #[test]
    fn test_chain_tip_inclusion_proof_decode() {
        // Verify that each field has been parsed in the correct position.
        let proof: ChainTipInclusionProof = deserialize_hex(CHAIN_TIP_PROOF_HEX).unwrap();

        assert_eq!(
            proof.proved_at_hash.to_string(),
            "6d11188b8ac69be193812aff2fc72251c021af15b9e0c4465ef877f3a648db06"
        );

        // Single UTXO proven at accumulator position 0
        assert_eq!(proof.proof.targets, vec![0]);

        // 3 sibling hashes needed to reconstruct the path to the root
        assert_eq!(proof.proof.hashes.len(), 3);

        // 1 leaf hash being proven for inclusion
        assert_eq!(proof.hashes_proven.len(), 1);
    }

    #[test]
    fn test_chain_tip_inclusion_proof_trailing_bytes() {
        // Valid proof with an extra `ff` byte appended. deserialize_hex must reject
        // trailing data to prevent accepting malformed or padded proofs.
        let hex = format!("{}ff", CHAIN_TIP_PROOF_HEX);
        let result: Result<ChainTipInclusionProof, _> = deserialize_hex(&hex);
        assert!(result.is_err());
    }

    #[test]
    fn test_chain_tip_inclusion_proof_truncated() {
        // Only the 32-byte block hash with no targets or hashes.
        // The parser must fail gracefully instead of panicking on missing data.
        let result: Result<ChainTipInclusionProof, _> = deserialize_hex(CHAIN_TIP_BLOCK_HASH_HEX);

        assert!(result.is_err());
    }
}
